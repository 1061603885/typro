### 闭包

 书上给闭包的定义如下：**有权访问另一个作用域中的变量的函数。** 

**举个最简单的闭包的栗子**：

```javascript
　function foo(){
　　　　var a = "变量";
　　　　return function(){
　　　　　　console.log(a)  
　　　　}
　　}
foo();
```

​     由于返回的函数需要使用到a变量，所以函数执行完毕后a变量不会被清除，以此实现变量私有化

 闭包在ie中会产生内存泄漏，因此变量不使用时要将他值变为null



```javascript
  window.onload = function(){
            var aLi = document.getElementsByTagName('li');
            for(var i=0;i<aLi.length;i++){
                (function(i){
                    aLi[i].onclick = function(){
                        alert(i); //0 1 2
                    }
                })(i) //将i作为参数传递给内部函数，i 在for循环执行完毕不会被释放
            }
        }

```



### 立即执行函数

```javascript
函数声明：function fname(){...}; 使用function关键字声明一个函数，再指定一个函数名。
函数表达式：var fname=function(){...}; 使用function关键字声明一个函数，但未给函数命名，最后将匿名函数赋予给一个变量。
匿名函数：function(){}; 使用function关键字声明一个函数，但未给函数命名。（匿名函数也属于函数表达式。）
（匿名函数作用很多，赋予一个变量则创建函数，赋予一个事件则成为事件处理程序等。。）
```

  特点：1.函数会立即执行，但是执行后立即会被销毁

 			2.避免污染全局变量



```javascript
var liList = ul.getElementsByTagName('li')
for(var i=0; i<6; i++){
  (function(j)//设置一个参数名，并且将后面的参数传入{
    liList[j].onclick = function(){
      alert(j) // 0、1、2、3、4、5
    }
  })(i)//传入外部的参数
}
```

 用立即执行函数给每个 li 创造一个独立作用域即可，此时每个 li 元素中的输出无法被循环改变，因为外面无法访问到。 



### 作用域和作用域链

#### 关于自由变量的取值

关于自由变量的值，上文提到要到父作用域中取，其实有时候这种解释会产生歧义。

```js
var x = 10
function fn() {
  console.log(x)
}
function show(f) {
  var x = 20
  (function() {
    f() //10，而不是20
  })()
}
show(fn)
```

在 fn 函数中，取自由变量 x 的值时，要到哪个作用域中取？——要到创建 fn 函数的那个作用域中取，**无论 fn 函数将在哪里调用**。



### 作用域与执行上下文

许多开发人员经常混淆作用域和执行上下文的概念，误认为它们是相同的概念，但事实并非如此。

我们知道 JavaScript 属于解释型语言，JavaScript 的执行分为：解释和执行两个阶段,这两个阶段所做的事并不一样：

#### 解释阶段：

- 词法分析
- 语法分析
- 作用域规则确定

#### 执行阶段：

- 创建执行上下文
- 执行函数代码
- 垃圾回收

```javascript
JavaScript 解释阶段便会确定作用域规则，因此作用域在函数定义时就已经确定了，而不是在函数调用时确定，但是执行上下文是函数执行之前创建的。执行上下文最明显的就是 this 的指向是执行时确定的。而作用域访问的变量是编写代码的结构确定的。
作用域和执行上下文之间最大的区别是：
执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变
```

