#### 标记清除

```jsjs
现在js使用的垃圾回收方式
工作原理:当环境进入变量时，将这个变量标记为"进入环境"。当变量离开环境时，则将其标记为"离开环境"。而被标记"离开环境"的即将会被后手内存.

流程:
1.垃圾回收器,在运行的时候会给 存储在内存中的所有变量 都加上标记
2.去掉环境中的变量 以及 被环境中的变量引用的变量 的标记
3.接下来还具有标记的变量会被视为准备删除的变量
4.垃圾回收器完成内存清除工作,销毁那些带标记的值并回收他们所占用的内存空间

```





#### 引用计数

```js
很久以前js用的垃圾回收机制,现在ie还在用(难怪这么菜)
工作原理:引用计数时跟踪记录每个值被引用的次数,被引用一次引用次数就+1,当引用次数为0时,就被视为回收的对象

流程:
1.声明了一个变量并将一个引用类型的值赋值给这个变量,这个引用类型的值就是1
2.同一个值又被赋值给另一个变量,这个引用类型值得引用次数加1
3.当包含这个引用类型值的变量又被数值成另一个值了,那么这个引用类型值的引用次数就+1
4.当引用次数变成0时,说明没办法访问这个值了
5.当垃圾收集器下一次运行时,它就会释放引用次数为0的值所占用的内存
```



#### 内存管理

```js
1、什么时候触发垃圾回收？
垃圾回收器周期性运行，如果分配的内存非常多，那么回收工作也会很艰巨，确定垃圾回收时间间隔就变成了一个值得思考的问题。
IE6的垃圾回收是根据内存分配量运行的，当环境中的变量，对象，字符串达到一定数量时触发垃圾回收。垃圾回收器一直处于工作状态，严重影响浏览器性能。
IE7中，垃圾回收器会根据内存分配量与程序占用内存的比例进行动态调整，开始回收工作。
2、合理的GC方案：(1)、遍历所有可访问的对象; (2)、回收已不可访问的对象。
3、GC缺陷：(1)、停止响应其他操作；
4、GC优化策略：(1)、分代回收（Generation GC）;(2)、增量GC
```



#### 开发中遇到的问题

```js
1、定义和用法：

内存泄露是指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束。C#和Java等语言采用了自动垃圾回收方法管理内存，几乎不会发生内存泄露。我们知道，浏览器中也是采用自动垃圾回收方法管理内存，但由于浏览器垃圾回收方法有bug，会产生内存泄露。

由于每次的垃圾回收开销都相对较大，并且由于机制的一些不完善的地方，可能会导致内存泄露。我们可以利用一些方法减少垃圾回收，并且尽量避免循环引用的问题。

例如，在对象结束使用后 ，令obj = null。这样利于解除循环引用，使得无用变量及时被回收。

再如，js中开辟空间的操作有new(), [ ], { }, function (){..}。在创建新对象的时候要尽量考虑增大对象的复用性。

2、内存泄露的几种情况:

虽然有垃圾回收机制，但是，我们编写代码操作不当还是会造成内存泄漏。

1.意外的全局变量引起的内存泄漏。

原因：全局变量，不会被回收。

解决：使用严格模式避免。

2.闭包引起的内存泄漏

原因：闭包可以维持函数内局部变量，使其得不到释放。

解决：将事件处理函数定义在外部，解除闭包,或者在定义事件处理函数的外部函数中，删除对dom的引用。

3.没有清理的DOM元素引用

原因：虽然别的地方删除了，但是对象中还存在对dom的引用

解决：手动删除。

4.被遗忘的定时器或者回调

原因：定时器中有dom的引用，即使dom删除了，但是定时器还在，所以内存中还是有这个dom。

解决：手动删除定时器和dom。

5.子元素存在引用引起的内存泄漏

原因：div中的ul li  得到这个div，会间接引用某个得到的li，那么此时因为div间接引用li，即使li被清空，也还是在内存中，并且只要li不被删除，他的父元素都不会被删除。

解决：手动删除清空。
```

